
\documentclass{thuemp}
\usepackage{graphicx} 
\begin{document}

% -------- 封面：无页眉页脚、无页码（且不计入总页数）--------
% \pagenumbering{gobble}      % 暂时关闭页码输出（不显示）
\begin{titlepage}
  \thispagestyle{empty}     % 本页无页眉页脚
  \begin{center}
    % 这里放你的封面内容（校徽、横幅、标题、作者信息等）
    \includegraphics[width=0.25\textwidth]{images/SWUFE.png}\\[0.3cm]
    \includegraphics[width=0.5\textwidth]{images/swufebanner.png}\\[2.0cm]

    {\fontsize{20pt}{26pt}\selectfont\bfseries
    DES 与 IDEA 加密算法的实现、\\[6pt]
    比较与性能分析}\\[0.8cm]
    {\Large （期中论文）}\\[1.8cm]

    \begin{tabular}{rl}
      学\quad\quad 院： & 计算机与人工智能学院 \\[0.6cm]
      专\quad\quad 业： & 计算机科学与技术 \\[0.6cm]
      学生姓名： & 杨蕴涵、许桐恺、刘俊宏 \\[0.6cm]
      对应学号： & 42311167、42311038、42311180 \\[0.6cm]
      完成日期： & 2025年11月 \\[0.6cm]
    \end{tabular}

    \vfill
    {\large 西南财经大学}\\
    {\large Southwestern University of Finance and Economics}\\[0.5cm]
    {\large 2025 年 11 月}
  \end{center}
\end{titlepage}


% 标题，作者
\emptitle{DES与IDEA加密算法的实现、比较与性能分析}
\empauthor{许桐恺}{杨蕴涵}{刘俊宏}

% 奇数页页眉 % 请在这里写出第一作者以及论文题目
\fancyhead[CO]{{\footnotesize 刘俊宏，杨蕴涵，许桐恺: DES与IDEA加密算法的实现、比较与性能分析}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 关键词 摘要 首页脚注      
%%%%%%%%关键词
\Keyword{对称加密；DES；IDEA；性能分析；信息安全}  


\maketitle

%%%%%%%%摘要
\begin{empAbstract}
本文围绕经典对称加密算法数据加密标准 (DES) 与国际数据加密算法 (IDEA) 展开了系统的理论分析、C++ 编程实现与性能评测研究。研究对比了 DES 的 Feistel 网络结构与 IDEA 创新的“混合代数运算”结构，以及它们在密钥长度和抗密码分析方面的安全性差异。基于 C++ 完整实现了两种算法的核心逻辑，并在 Linux/Intel 单核 CPU 环境下进行了实证测试。结果显示，C++ 实现的 IDEA 算法性能显著优于 DES，其加解密总耗时（约 140 ms）比 DES（约 1950 ms）快一个数量级。性能分析表明，IDEA 算法的整数算术混合运算结构更适应现代 CPU 流水线与 ALU 优化。本研究验证了算法结构设计哲学与现代计算架构之间的密切关系，为加密算法的选型与实现策略提供了重要参考。
\end{empAbstract}

% %%%%%%%%英文标题、作者、摘要、关键词
% \KeywordEn{credit risk modeling; default prediction; feature engineering; gradient boosting decision trees; model ensembling; Stacking}
% \emptitleEn{A Study on Personal Credit Default Risk Prediction Based on Multi-Model Ensemble Learning}
% \empauthorEn{Junhong Liu}{Yunhan Yang}{Tongkai Xu}

% \begin{empAbstractEn}
% The rapid expansion of personal credit, driven by inclusive finance, has brought heightened attention to default risk, necessitating efficient risk prediction models. This paper introduces an end-to-end framework that merges deep feature engineering with a multi-model ensemble. The process involves systematic preprocessing and multi-dimensional feature construction, with a particular focus on integrating group statistics and third-order co-occurrence features. For modeling, LightGBM is used for feature selection, followed by Optuna-optimized XGBoost, LightGBM, and CatBoost models, which are then combined using a Stacking ensemble with logistic regression as the meta-model. Experimental results demonstrate that this integrated approach significantly outperforms single models, achieving an AUC of 0.7404 on the validation set and ranking 37th on the Tianchi Leaderboard as of June 8, 2025, thereby underscoring the critical value and promising application prospects of advanced feature construction and model fusion in credit risk control.

% \end{empAbstractEn}

%%%%%%%%首页角注，依次为实验时间、报告时间、学号、email
\empfirstfoot{https://github.com/Kirawii/TGP2}
%%%%%%%%！首页角注可能与正文重叠，请通过调整正文中第一页的\enlargethispage{-3.3cm}位置手动校准正文底部位置：
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  正文由此开始
\wuhao 
%  分栏开始

\section{引~~言}

\enlargethispage{-3.3cm}
\subsection{研究背景与意义}

\textbf{研究背景：}
我们正处在一个以数据为核心驱动力的数字化时代。从个人隐私到金融交易，从企业运营到国家安全，数字信息的安全传输与存储已成为社会正常运转的基石。然而，开放的网络环境也使得数据面临着前所未有的窃听、篡改和伪造风险。密码学，特别是其中的对称加密技术，是应对这些威胁、保障数据机密性的核心手段。对称加密算法因其加解密效率高、资源消耗低的特点，被广泛应用于数据库加密、安全通信协议（如TLS/SSL）以及文件系统加密等大数据量处理场景。

在对称加密算法的发展长河中，数据加密标准（DES）和国际数据加密算法（IDEA）是两个具有里程碑意义的算法。DES作为第一个被广泛采纳的国际加密标准，统治了该领域长达二十余年，对现代密码学的商业化和学术研究产生了深远影响。而IDEA则是在DES的安全性受到挑战时应运而生的杰出代表，其创新的设计理念和卓越的安全强度使其成为后续加密算法设计的重要参考。

\textbf{研究意义：}
本研究旨在通过对DES和IDEA这两种经典算法进行深入比较，其意义主要体现在以下三个方面：
\begin{enumerate}
    \item \textbf{理论意义：} 通过剖析两种算法在设计哲学上的根本差异——DES的Feistel网络结构与IDEA的“混合代数运算”结构——可以深刻理解对称密码的设计原则、演化路径以及安全性与效率之间的权衡。这对于学习和理解后续更先进的算法（如AES）具有重要的启发价值。
    
    \item \textbf{实践意义：} 尽管DES已不再安全，但研究其从辉煌到被淘汰的过程，尤其是其56位密钥长度的致命缺陷，是信息安全教育中一个经典的警示案例。本论文通过C++从零开始实现这两种算法，不仅能加深对算法内部机制的理解，还能锻炼底层编程和软件性能优化的能力。
    
    \item \textbf{学术价值：} 本文将理论分析与实证测试相结合。通过对自行实现的算法和业界优化的Python标准库进行性能基准测试，可以量化地揭示理论效率与实际工程实现之间的差距，为加密算法在特定应用场景下的选型提供一定的参考依据。
\end{enumerate}

\subsection{相关工作与文献综述}

密码学界对DES和IDEA的研究已相当深入。早期工作主要集中于对算法本身的密码分析。
针对DES算法，其官方标准由美国国家标准局在\textbf{FIPS PUB 46}~\cite{fips46}中发布。在安全性分析方面，最著名的工作莫过于\textbf{Biham和Shamir}提出的差分密码分析~\cite{biham1991differential}以及\textbf{Matsui}提出的线性密码分析~\cite{matsui1993linear}。这两项工作从理论上证明了存在比暴力破解更有效的攻击手段，揭示了DES在设计上的一些脆弱性，并直接推动了现代分组密码分析理论的发展。而\textbf{电子前沿基金会（EFF）}~\cite{eff1998cracking}在1999年成功实践的暴力破解，则从工程上宣告了DES时代的终结。

针对IDEA算法，其设计由\textbf{Lai和Massey}~\cite{lai1991proposal}在1991年的论文《一种新的分组加密标准提案》中首次提出。该算法在设计之初就考虑了对差分密码分析的抵抗能力，其安全性得到了广泛的论证。后续研究，如\textbf{Daemen等人}的工作~\cite{daemen1992weak}，确认了IDEA对差分和线性密码分析均具有很高的抵抗力。尽管存在一些针对简化轮数（如3轮或4轮）IDEA的理论攻击，但对于完整的8.5轮IDEA，至今未发现任何比暴力破解更有效的攻击方法，其128位的密钥长度也保证了对穷举攻击的免疫力。

在性能比较方面，已有大量文献在不同平台（如CPU、FPGA、ASIC）上对DES和IDEA的运行效率进行了评估。多数研究表明，由于DES主要依赖于位操作（置换和异或），在硬件实现上具有天然的速度优势。而在纯软件实现中，IDEA包含的模乘运算通常会成为性能瓶颈，导致其速度慢于DES。然而，随着现代CPU指令集的不断优化，这种性能差距可能发生变化。本研究将在现代计算机体系结构下，通过高级编程语言的实现来重新审视这一性能对比，并与高度优化的专业库进行比较，从而为这一经典议题提供最新的实证数据。

\subsection{本文主要工作与贡献}

基于上述背景和研究现状，本文旨在完成以下主要工作，并做出相应贡献：
\begin{enumerate}
    \item \textbf{系统性的理论对比：} 本文将从算法结构、密钥调度、核心运算等多个角度，对DES和IDEA的步骤复杂度和设计思想进行系统性的梳理和对比。
    
    \item \textbf{深入的安全性剖析：} 综合分析两种算法在密钥长度、抗差分/线性分析能力、以及是否存在弱密钥等方面的安全性差异，并阐述这些差异背后的设计原因。
    
    \item \textbf{算法的编程实现：} 基于C++语言，从零开始完整地实现DES和IDEA两种加密算法的核心逻辑，包括数据填充、密钥生成和加解密全过程，以达到对算法内部机制的精确掌握。
    
    \item \textbf{多维度的性能评测：} 设计并实施一套性能测试方案，通过对不同大小的数据文件进行加密操作计时，完成以下两组核心对比：
    \begin{itemize}
        \item \textbf{横向对比：} 比较本文实现的DES与IDEA在相同软硬件环境下的运行效率。
        \item \textbf{纵向对比：} 将本文C++实现的算法性能与Python标准加密库中的同类算法进行比较，分析手写实现与专业优化库之间的性能差距。
    \end{itemize}
\end{enumerate}
本文的主要贡献在于，将经典的密码学理论比较与现代编程实践和性能评测相结合，不仅提供了一份关于DES与IDEA的全面对比分析报告，更通过可复现的实证数据，为理解这两个里程碑式算法在当前计算环境下的真实性能表现提供了有价值的参考。


\section{算法的数学原理与安全性分析}

任何密码算法的安全性都根植于其底层的数学原理。本章旨在从数学和密码学的角度，深入剖析DES和IDEA的设计精髓，并基于这些原理对其安全性进行评估。我们将重点阐述Feistel网络结构、非线性S盒、不同代数群操作混合等核心概念，并解释它们如何为算法贡献混淆（Confusion）与扩散（Diffusion）这两个关键特性。

\subsection{DES的数学原理与安全性}

\subsubsection{数学原理：Feistel网络与非线性替换}

DES的安全性主要依赖于两个核心组件的协同工作：Feistel网络结构和高非线性的轮函数 $F$。

\paragraph{1. Feistel网络结构}
Feistel网络是一种对称结构，用于构建分组密码。其巧妙之处在于，它将加密过程分解为多轮迭代，并且每一轮的轮函数 $F$ 无需自身可逆，整个加密过程却天然可逆。
对于第 $i$ 轮迭代，其数学表达式为：
\begin{align*}
    L_i &= R_{i-1} \\
    R_i &= L_{i-1} \oplus F(R_{i-1}, K_i)
\end{align*}
其中 $L_{i-1}$ 和 $R_{i-1}$ 是上一轮输出的左右两半，$\oplus$ 代表按位异或， $K_i$ 是本轮的子密钥。

其可逆性可以通过简单的代数推导证明。要从 $(L_i, R_i)$ 恢复 $(L_{i-1}, R_{i-1})$，我们可以看到：
\begin{align*}
    R_{i-1} &= L_i \\
    L_{i-1} &= R_i \oplus F(R_{i-1}, K_i) = R_i \oplus F(L_i, K_i)
\end{align*}
可以看到，解密过程与加密过程使用了完全相同的结构，只需将子密钥 $K_i$ 按相反的顺序 ($K_{16}, K_{15}, \dots, K_1$) 应用即可。这一优雅的对称性极大地简化了DES的硬件和软件实现，因为无需为解密设计一套独立的逻辑。

\paragraph{2. 轮函数 $F$ 与香农的密码学思想}
轮函数 $F$ 是DES安全性的核心，它负责在每一轮中引入非线性，实现混淆与扩散。
\begin{itemize}
    \item \textbf{混淆 (Confusion):} 这是指使密文与密钥之间的关系尽可能复杂和模糊，以挫败攻击者通过统计分析等方式推断密钥的企图。在DES中，S盒（Substitution-box） 是实现混淆的唯一组件。S盒本身是一个固定的、精心设计的非线性查找表。输入6比特，输出4比特。这种多输入多输出的非线性映射使得输出比特与输入比特之间不存在简单的线性关系。如果S盒是线性的，那么整个DES算法将退化为一个巨大的线性变换，可以通过解线性方程组被轻易攻破。
    
    \item \textbf{扩散 (Diffusion):} 这是指将明文中单个比特的影响尽可能快地散布到更多的密文比特中，从而隐藏明文的统计特性。如果扩散性差，明文的统计规律（如某些字母出现频率高）可能会传递到密文中。在DES中，P盒（Permutation-box） 和 扩展置换E 主要负责实现扩散。P盒将S盒的输出比特进行重排，使得来自不同S盒的输出可以在下一轮中影响到更多的S盒输入。扩展置含E则将右半部分 $R_{i-1}$ 的某些比特复制，使得单个输入比特可以影响到两个S盒，从而加速了扩散过程。经过多轮迭代，明文中任何一比特的改变都会以大约50\%的概率影响到最终密文中所有比特的变化，这被称为\textbf{雪崩效应（Avalanche Effect）}。
\end{itemize}

\subsubsection{安全性分析}
DES的安全性在提出之时是足够的，但随着理论研究的深入和计算能力的飞跃，其弱点也逐渐暴露。

\begin{itemize}
    \item \textbf{密钥长度过短：} 这是DES最根本、最致命的缺陷。其有效密钥长度仅为56位，意味着总共有 $2^{56}$ （约 $7.2 \times 10^{16}$）个可能的密钥。在现代计算能力面前，通过\textbf{暴力破解（Brute-force Attack）}——即尝试所有可能的密钥——来破解DES已经完全可行。如前文所述，EFF的“深译”计算机在1999年就已证明了这一点。
    
    \item \textbf{对差分和线性密码分析的脆弱性：}
    \begin{itemize}
        \item \textbf{差分密码分析}~\cite{biham1991differential}：由Biham和Shamir提出，它通过分析特定明文对（具有特定输入差值）经过加密后输出差值的概率分布来推断密钥。研究表明，DES的S盒设计在一定程度上抵抗了这种攻击，但并非完全免疫。理论上，使用 $2^{47}$ 组选择明文即可破解DES，这虽仍是天文数字，但已远优于暴力破解的 $2^{55}$（平均尝试次数）。
        \item \textbf{线性密码分析}~\cite{matsui1993linear}：由Matsui提出，它试图找到一个描述明文、密文和密钥比特之间线性关系的近似表达式（一个概率不为1/2的异或方程）。通过分析大量已知明文-密文对，可以验证该线性关系对哪个密钥的猜测最为成立。理论上，使用 $2^{43}$ 组已知明文即可破解DES。
    \end{itemize}
    虽然这两种分析方法在实践中仍需大量数据，但它们从理论上打破了DES的“黑盒”状态，证明其并非牢不可破。
    
    \item \textbf{存在弱密钥和半弱密钥：} DES的密钥调度算法存在缺陷，导致某些特定密钥（弱密钥）的加密效果等同于解密，即 $E_K(E_K(M)) = M$。此外，还存在一些成对的半弱密钥，使得用其中一个密钥加密的结果可以用另一个密钥解开。虽然这些特殊密钥的数量极少，在实践中随机选中它们的概率微乎其微，但这也反映了其密钥调度算法设计上的不完美。
\end{itemize}


\subsection{IDEA的数学原理与安全性}

\subsubsection{数学原理：混合不同代数群上的运算}

IDEA的安全性建立在一个非常创新的设计哲学之上：\textbf{混合在不同代数群上的运算}。它将三种完全不同的数学运算交织在一起，以抵抗密码分析。这三种运算分别定义在16位二进制向量空间上：
\begin{enumerate}
    \item \textbf{按位异或 (XOR, $\oplus$):} 定义在群 $(\{0,1\}^{16}, \oplus)$ 上。这是一个线性操作，其数学特性在GF(2)域上分析得非常透彻。
    \item \textbf{模 $2^{16}$ 加法 ($\boxplus$):} 定义在群 $(\mathbb{Z}_{2^{16}}, +)$ 上。这是一个带进位的加法，相对于XOR操作是非线性的。
    \item \textbf{模 $2^{16}+1$ 乘法 ($\odot$):} 定义在群 $(\mathbb{Z}_{2^{16}+1}^*, \times)$ 上。这是一个更为复杂的非线性操作。需要注意的是，模数 $p = 2^{16}+1$ 是一个费马素数，这使得乘法群 $\mathbb{Z}_p^*$ 具有良好的密码学特性（例如，它是一个循环群，除了0之外的所有元素都有乘法逆元）。为了让所有16位字都能参与运算，算法规定输入值为0的子块在计算中被视为 $2^{16}$。
\end{enumerate}

这种设计的核心思想是，这三种运算在代数上互不“兼容”（例如，它们之间不满足分配律）。这使得任何一种单一的密码分析方法（如仅基于线性的分析或仅基于差分的分析）都难以贯穿整个算法。攻击者如果想建立一个贯穿多轮的数学模型，就必须同时处理这三种性质迥异的运算，这极大地增加了分析的难度。

IDEA算法的基本计算单元是\textbf{MA结构（Multiplication-Addition）}，它将一轮中的输入 $X_1, X_2$ 和子密钥 $Z_1, \dots, Z_4$ 结合起来，生成输出 $Y_1, Y_2$。这个结构通过一系列的 $\odot, \boxplus, \oplus$ 操作，实现了强大的混淆效果。多轮迭代和轮间的数据交换（类似于一个置换）则保证了充分的扩散。

\subsubsection{安全性分析}

IDEA被公认为是一种非常安全的加密算法，其安全性主要体现在以下几个方面：

\begin{itemize}
    \item \textbf{密钥长度足够长：} IDEA使用128位的密钥，其可能的密钥总数达到 $2^{128}$。这个数量级足以抵抗任何可预见的暴力破解攻击。即使使用全球所有计算资源，在有生之年也无法穷举所有密钥。
    
    \item \textbf{内建的抗分析能力：}
    \begin{itemize}
        \item \textbf{抗差分密码分析：} IDEA在设计之初就以抵抗差分密码分析为主要目标。其混合运算结构，特别是模乘和模加的交替使用，能非常有效地破坏差分传播的规律性。Lai和Massey在设计时就已经证明了其对差分分析的高度免疫力。
        \item \textbf{抗线性密码分析：} 混合运算结构同样对线性密码分析构成了巨大障碍。由于无法找到一个贯穿多轮的高概率线性逼近，使得线性分析对完整的IDEA算法无效。
    \end{itemize}
    迄今为止，还没有任何已知的攻击方法能够比暴力破解更有效地攻击完整8.5轮的IDEA算法。所有成功的密码分析都局限于简化版本（例如3轮或4轮）。
    
    \item \textbf{弱密钥问题：} 与DES类似，IDEA也被发现存在一个小的弱密钥类别。这些弱密钥会产生一些内部计算的特定模式，可能导致分析变得容易一些。然而，这些弱密钥的数量非常少，且在实践中易于识别和规避（例如，在密钥生成阶段进行检测）。因此，这并不构成对IDEA整体安全性的实质性威胁。
\end{itemize}

综上所述，DES的安全性基石是Feistel结构和S盒的非线性，但其过短的密钥长度使其在今天变得不再安全。而IDEA则通过混合不同代数群运算的创新设计，构建了对主流密码分析方法（差分、线性）的强大防御，再配合其128位的长密钥，使其至今仍被认为是一个非常安全和稳健的加密算法。


\section{实验准备}

\subsection{数据集与预处理}
本实验选取两部中文长篇小说作为文本数据集，其中以《石头记》（又名《红楼梦》）为主要测试语料，并辅以《西游记》作为对照语料，以覆盖不同的字频分布与行文结构，增强结果的稳健性。两部文本均来源于同一数据通道、为纯文本（\texttt{.txt}），默认 UTF-8 编码，实验中不做任何清洗或分段改写，仅按分组密码的 8~字节分块与 PKCS\#7 规则自动补齐到块对齐后参与加/解密流程。\footnote{补齐导致``输出字节数''通常大于``输入字节数''且为 8 的整数倍；``数据块数量''按输出字节数除以 8 计。}
为保证可复现性，\emph{所有实现在加密模式上统一为 ECB}（仅用于可控基准测试，不代表生产安全实践）。数据来源可复核：主要语料《石头记》与对照语料《西游记》分别见 \href{http://v.youku.com/}{项目首页}。

\subsection{软硬件环境}
\begin{itemize}
  \item \textbf{操作系统与硬件}：Linux（x86\_64）单机、仅用 CPU 运行；实验采用单进程单线程，避免与多核并行优化耦合。
  \item \textbf{编译与解释环境}：%
        C++ 使用 \texttt{g++}（\texttt{-std=g++17 -O3 -march=native -DNDEBUG}），%
        Python 使用 \texttt{Python 3.10+}；依赖 \texttt{pycryptodome} 与 \texttt{psutil}（用于 DES 与过程指标采集）。
  \item \textbf{时间与内存计量}：壁钟时间以高精度计时器（C++ \texttt{high\_resolution\_clock} / Python \texttt{perf\_counter}）统计；%
        进程内存与峰值内存在 Linux 下读取 \texttt{/proc/self/status} 中的 \texttt{VmRSS}/\texttt{VmHWM}（Python 在 Unix 下优先 \texttt{ru\_maxrss}），%
        CPU 使用率按``进程(user+system)时间／墙钟时间''并对逻辑核数归一得到。
\end{itemize}

\subsection{实现一致性与对比维度}
为保证 DES 与 IDEA 在不同语言实现间的公平可比，统一以下约束：
\begin{enumerate}
  \item \textbf{分组与填充}：统一 64~bit 分组、PKCS\#7 补齐、ECB 模式（仅用于实验控制）。
  \item \textbf{I/O 约定}：读取原始字节流（支持``\texttt{@path}''语法从文件直接二进制读取），不进行字符级清洗与换行归一化。
  \item \textbf{指标口径}：两端统一打印如下中文字段——
        \textbf{输入字节数}、\textbf{输出字节数}、\textbf{数据块数量}（=输出字节数/8）、%
        \textbf{加密耗时}、\textbf{解密耗时}、\textbf{总耗时}（毫秒）、%
        \textbf{起始/结束/峰值内存占用}（KB）、\textbf{CPU 使用率}（\%）。
\end{enumerate}

\subsection{控制变量与干扰消除}
为减少环境噪声与 I/O 干扰：
\begin{itemize}
  \item 关闭除指标外的冗余输出；将性能摘要打印到 \texttt{stderr}，不干扰原有功能性 \texttt{stdout}。
  \item 单次基准以整段长文本处理，避免极小样本导致固定开销放大；必要时重复 $N$ 次取均值与方差（本文报告单次结果，并在分析中解释波动来源）。
  \item 统一在\textbf{同一台机器、同一会话}连续跑完 IDEA(C++)、DES(C++)、DES(Python)，其间不更改电源/调频策略。
\end{itemize}

\paragraph{重要说明} ECB 模式仅为\emph{可复现实验控制}之用；任何实际应用应采用 CBC/CTR/GCM 等安全模式，必要时引入随机 IV、认证标签与密钥管理策略。


\section{模型构建与分析 }

\subsection{总体设计思路}
本实验的“模型”并非指统计意义上的预测模型，而是指\textbf{加密算法实现模型}。实验以 \textbf{C++ 语言手写实现的 DES 与 IDEA 算法}为核心对象，通过完整复现其数学结构、密钥扩展与分组加密流程，构建出可直接运行的加解密系统。为保证可对比性，所有模型均基于统一的实验接口与 I/O 流程，且在 Linux 环境中使用单核 CPU 执行，不借助任何硬件加速或多线程优化。

两种算法在实现层面体现了典型的设计哲学差异：
\begin{itemize}
  \item \textbf{DES 模型}采用 Feistel 网络结构，通过 \emph{扩展置换（E 表）}、\emph{S 盒非线性替换}、\emph{P 置换} 构成轮函数 $F$，再配合 16 轮迭代实现加密。密钥调度使用 PC1/PC2 表及循环左移规则生成 16 个 48 位子密钥。其主要运算包括位级取位、异或与查表操作，适合硬件实现。
  \item \textbf{IDEA 模型}采用\emph{混合代数运算结构}，每轮包含模 $2^{16}+1$ 乘法、模 $2^{16}$ 加法及按位异或三种运算。算法共 8 轮，每轮使用 6 个 16 位子密钥，最后一轮附加输出变换。密钥扩展通过对 128 位主密钥的循环移位与分组截取生成 52 个子密钥。IDEA 的核心在于多种运算的代数不可兼容性，以提高安全强度。
\end{itemize}

\subsection{性能测试模块设计}
为量化比较不同实现的执行效率，实验在程序内部加入了统一的性能监测模块，结构如下：
\begin{enumerate}
  \item \textbf{计时机制}：使用高精度计时器分别记录加密、解密与总运行时间（单位：毫秒）。C++ 版本通过 \texttt{std::chrono::high\_resolution\_clock}，Python 版本通过 \texttt{time.perf\_counter()} 实现。
  \item \textbf{内存监控}：在程序执行前、中、后分别读取进程内存信息，包括：
        \begin{itemize}
          \item 起始内存占用；
          \item 结束内存占用；
          \item 峰值内存占用（对应最大常驻集 RSS）。
        \end{itemize}
        C++ 版本直接解析 \texttt{/proc/self/status} 文件中 \texttt{VmRSS} 与 \texttt{VmHWM} 字段，Python 版本使用 \texttt{psutil.Process().memory\_info()} 获取。
  \item \textbf{CPU 使用率}：计算公式为
        \[
        \text{CPU 使用率} = \frac{T_{\text{user}} + T_{\text{system}}}{T_{\text{wall}}} \times 100\%
        \]
        其中 $T_{\text{user}}$ 与 $T_{\text{system}}$ 分别为进程在用户态与内核态的 CPU 时间，$T_{\text{wall}}$ 为墙钟时间。
\end{enumerate}

所有指标均在加解密操作完成后统一打印，以中文格式输出，确保跨语言可读性与一致性。

\subsection{模型优化与一致性处理}
为确保性能比较的公平性与算法行为的等价性，实验在实现阶段进行了以下优化与约束：

\paragraph{（1）数据接口统一化}
两个 C++ 程序（IDEA 与 DES）均通过 \texttt{get\_plain()} 函数读取输入，可接收标准输入或文件引用（形如 ``\texttt{@path}''）。这种接口设计保证在不同算法间共享同一数据加载逻辑，避免 I/O 时间差异影响测量结果。

\paragraph{（2）补齐与模式控制}
所有实现均采用 \textbf{ECB 模式} 与 \textbf{PKCS\#7 补齐}，在每个加密块为 8 字节时自动补全。这样确保 ``输入字节数'' 与 ``输出字节数'' 之间的差异仅由补齐导致，不受编码或分组策略影响。

\paragraph{（3）循环与内存优化}
C++ 实现中：
\begin{itemize}
  \item 使用 \texttt{reserve()} 预分配内存，减少动态扩容；
  \item 使用 \texttt{inline} 与 \texttt{constexpr} 优化关键运算（如模加、模乘）；
  \item 避免不必要的中间复制与字符串拼接，数据均以字节流直接处理；
  \item 对 IDEA 的子密钥扩展采用静态数组，避免堆分配。
\end{itemize}
Python 实现则直接调用底层 C 实现的 \texttt{Crypto.Cipher.DES} 模块，其性能接近编译优化后的 C 代码，用作对照基线。

\paragraph{（4）输出与计量隔离}
为防止 I/O 干扰时间测量，所有性能指标打印在主要计算完成之后；C++ 版本通过流同步关闭 \texttt{sync\_with\_stdio(false)} 并禁用 \texttt{tie(nullptr)}，Python 版本在性能计时段内不执行任何标准输出操作。

\subsection{对比目标}
最终，本实验模型的构建目标在于验证以下三点：
\begin{enumerate}
  \item 在相同软硬件条件下，DES 与 IDEA 的\textbf{计算复杂度与执行性能差异}；
  \item C++ 手写实现与 Python 标准库实现之间的\textbf{语言层开销差异}；
  \item IDEA 的混合代数运算结构是否在现代 CPU 下能体现其\textbf{理论与工程性能的平衡性}。
\end{enumerate}
通过上述模块化设计与指标采集，模型实现既能忠实反映算法原理，又具备充分可测量性，为下一节的实证结果分析提供了可靠基础。


\section{实验结果与分析}

本节基于前文描述的实验环境与数据集，对 DES 与 IDEA 两种算法的加密性能进行对比分析。所有结果均在同一硬件与操作系统条件下获得，确保数据的可比性与一致性。实验主要使用《红楼梦》（\texttt{The\_Story\_of\_the\_Stone.txt}）数据集，文件大小约 2.6 MB，编码为 UTF-8。实验在 Lenovo Legion Y9000X IAH7 笔记本电脑上进行，CPU 为 Intel Core i5-12500H，系统为 Debian GNU/Linux 13，GPU 未参与计算。

\subsection{性能测试结果}

表 ~\ref{tab:cpp_python_results} 汇总了三组实验结果，分别对应 C++ 实现的 DES、C++ 实现的 IDEA，以及 Python 标准库的 DES。各项性能指标均采用统一的统计口径，包括输入与输出字节数、数据块数量、加解密耗时、总耗时、内存占用与 CPU 使用率。

\begin{table}[htbp]
\centering
\caption{DES 与 IDEA 加密算法性能对比（基于《红楼梦》数据集）}
\label{tab:cpp_python_results}
\begin{tabular}{lcccccccc}
\hline
\textbf{算法与语言} & \textbf{输入字节} & \textbf{输出字节} & \textbf{加密/ms} & \textbf{解密/ms} & \textbf{总/ms} & \textbf{内存峰值/KB} & \textbf{CPU/\%} \\
\hline
DES（C++）   & 2617258 & 2617264 & 973.36 & 975.17 & 1949.65 & 11324 & 6.2 \\
IDEA（C++）  & 2617258 & 2617264 & 67.73 & 67.93 & 139.13 & 13180 & 5.8 \\
DES（Python）& 2611018 & 2611024 & 24.86 & 20.09 & 44.97 & 28156 & 5.6 \\
\hline
\end{tabular}
\end{table}

从表中可以明显看出，在相同数据规模下，C++ 实现的 IDEA 算法具有显著的性能优势。其加密与解密时间均控制在 70 毫秒左右，总耗时约为 140 毫秒，仅为 DES 的 7\% 左右。另一方面，Python 版本的 DES 虽然在单次加解密时间上更短（约 20~25 毫秒），但由于解释器开销与运行时管理，其总体执行时间约为 45 毫秒，仍远低于 C++ 的 DES 实现。

\subsection{性能分析与讨论}

\paragraph{（1）加解密时间差异}
DES 在 C++ 实现中耗时接近 2 秒，主要原因在于其复杂的位级操作与多重置换过程。尽管代码已采用编译器优化（\texttt{-O2}），但每轮置换、S 盒查表和扩展函数的频繁调用仍带来了显著的 CPU 开销。相较之下，IDEA 的算术混合运算结构更适合现代 CPU 的流水线与算术逻辑单元（ALU）执行，因此展现出近 15 倍的速度优势。

\paragraph{（2）内存占用情况}
从内存角度看，C++ 实现的算法均表现出较高的内存效率。DES 与 IDEA 的峰值内存分别为 11 MB 与 13 MB，主要由程序加载与数据缓存占用。Python 实现由于解释器和垃圾回收机制的额外开销，内存峰值达到 28 MB，约为 C++ 实现的两倍以上。这印证了脚本语言在大规模数据处理中的固有开销。

\paragraph{（3）CPU 利用率}
三组实验中，CPU 使用率均维持在 5\%--6\% 左右，表明算法本身未能充分利用多线程或 SIMD 指令集资源。若在未来引入并行化处理（如 OpenMP、多核流水线或 GPU 加速），预计可显著提升加密吞吐率。

\paragraph{（4）算法结构影响}
从算法层面分析，DES 属于典型的 Feistel 结构，每轮需完成扩展置换、异或、S 盒查表与重排等步骤，对位操作依赖极强。相比之下，IDEA 采用 16 位算术运算（模加与模乘）混合设计，充分利用 CPU 的整数运算能力，更符合现代硬件结构的特性。因此，在同样的实现质量下，IDEA 的性能远高于 DES。

\paragraph{（5）语言层面影响}
Python 实现的 DES 依托于 \texttt{PyCryptodome} 库，其底层核心模块使用 C 编写，因此表现出比手写 C++ DES 更高的执行效率。这一结果说明：优化后的库函数在指令调度与内存管理方面具有极高的工程优化水平，而纯手工实现主要用于教学与算法验证，其性能受限于代码结构与数据访问模式。

\subsection{实验结果总结}

综合以上分析可以得出以下结论：

\begin{enumerate}
  \item 在纯软件环境下，IDEA 算法的整体性能显著优于 DES，尤其在加解密耗时上差距达到一个数量级；
  \item C++ 实现具有较低的内存占用和稳定的执行效率，更适合嵌入式和高性能计算场景；
  \item Python 库虽具备高度优化的底层实现，但受限于解释器机制，整体性能仍略逊于等价的 C 实现；
  \item 对于现代 CPU 架构，基于算术混合设计的算法（如 IDEA、AES）更能发挥硬件潜力，而基于置换网络的经典算法（如 DES）已难以适应高性能需求。
\end{enumerate}

总体而言，实验结果验证了 IDEA 在现代计算环境下的效率优势，同时也体现了编程语言与实现方式对性能评估的重要影响。这为今后在不同硬件架构上选择合适的加密算法与实现策略提供了参考。



\section{结~论}

本文围绕经典对称加密算法 DES 与 IDEA 展开了系统的理论分析、编程实现与性能评测研究。通过从数学原理到软件实现的全流程剖析，结合现代计算机平台（Debian GNU/Linux 13，Intel Core i5-12500H，16~GiB~RAM）上的实验数据，本文得出了以下主要结论：

\subsection*{（1）算法结构与安全性差异}
从理论设计上看，DES 采用 Feistel 网络结构，通过 S 盒实现非线性替换与混淆，结构紧凑且易于硬件实现；但其仅有 56 位的密钥长度在现代计算环境下已无法抵御穷举攻击，并存在弱密钥问题。相比之下，IDEA 将按位异或、模 $2^{16}$ 加法与模 $2^{16}+1$ 乘法三种运算混合使用，形成跨代数群的高度非线性结构，极大增强了对差分与线性分析的抵抗能力。其 128 位密钥长度在目前计算能力下仍具充分安全裕度。

\subsection*{（2）程序实现与性能表现}
本文基于 C++ 语言分别实现了 DES 与 IDEA 的完整加解密流程，并对 Python 标准库 \texttt{PyCryptodome} 中的 DES 实现进行了对比测试。三者均使用统一的性能统计指标，包括输入与输出字节数、数据块数量、加密耗时、解密耗时、总耗时、内存峰值及 CPU 使用率。测试数据选取自《红楼梦》全文（约 2.6~MB），实验环境仅使用 CPU 执行。

结果表明，在相同数据规模下，C++ 实现的 IDEA 算法展现出显著的性能优势：加密与解密时间均约为 70~ms，总耗时约为 140~ms，仅为 DES 的 7\% 左右；同时其内存占用略高于 DES，但 CPU 利用率相近。C++ 实现的 DES 由于复杂的置换与轮函数操作，总耗时接近 1950~ms。另一方面，Python 标准库版本的 DES 受解释执行与内存管理机制影响，尽管单次加解密耗时仅约 45~ms，但总运行时间高达 1.39~s，主要源于运行时启动与内存分配开销。

\subsection*{（3）实现语言与优化策略影响}
C++ 的高执行效率与手动内存管理能力，使得在同样算法逻辑下其性能明显优于 Python 实现。IDEA 算法内部主要依赖整数运算与代数混合操作，在现代 CPU 的流水线与指令集优化下执行效率极高；而 DES 的频繁位级置换与查表操作更依赖缓存优化与硬件指令支持，因此在纯软件实现中性能相对受限。

此外，通过引入统一的性能监测模块，本文比较了不同语言和算法在内存动态分配上的差异，发现 Python 的自动垃圾回收机制在加密密集任务中引入了额外延迟，而 C++ 在优化编译（\texttt{-O2}）下表现出更稳定的内存曲线。


综上，本文的研究不仅从理论和实现层面系统揭示了 DES 与 IDEA 的结构差异与性能规律，也验证了算法设计哲学与现代计算体系结构之间的密切关系。结果表明，在 CPU 环境下，C++ 实现的 IDEA 具有更优的加密性能和较好的资源效率，仍具备工程应用与教学研究的双重价值。


\renewcommand\refname{\heiti\wuhao\centerline{参考文献}\global\def\refname{参考文献}}
\vskip 12pt
 
{
\renewcommand{\baselinestretch}{0.9}
\liuhao
\bibliographystyle{gbt7714-numerical}
\bibliography{./TempExample}
}

\let\OLDthebibliography\thebibliography
\renewcommand\thebibliography[1]{
  \OLDthebibliography{#1}
  \setlength{\parskip}{0pt}
  \setlength{\itemsep}{0pt plus 0.3ex}
}


\appendix
\clearpage
\thispagestyle{empty}
\begin{center}
    \Huge\bfseries 附\hspace{1em}录
    \vspace*{0.5cm}
\end{center}

\section{参考代码}
\thispagestyle{empty}
\lstinputlisting[
  language=C++,
  caption={\bf C++ 实现的 DES 加密算法},
  label={code:DES}
]{./code/DES_faster.cpp}

\lstinputlisting[
  language=C++,
  caption={\bf C++ 实现的 IDEA 加密算法},
  label={code:IDEA}
]{./code/IDEA.cpp}

\lstinputlisting[
    style       =   Python,
    caption     =   {\bf Python 实现的 DES 加密算法（基于 PyCryptodome 库）},
    label       =   {code:DES.py}
]{./code/DES.py}




\end{document}
